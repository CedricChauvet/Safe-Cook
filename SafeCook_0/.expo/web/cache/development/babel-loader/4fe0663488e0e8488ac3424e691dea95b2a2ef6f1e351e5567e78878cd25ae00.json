{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPathFromState = getPathFromState;\nvar queryString = _interopRequireWildcard(require(\"query-string\"));\nvar _getPatternParts = require(\"./getPatternParts.js\");\nvar _validatePathConfig = require(\"./validatePathConfig.js\");\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof WeakMap) return null;\n  var r = new WeakMap(),\n    t = new WeakMap();\n  return (_getRequireWildcardCache = function (e) {\n    return e ? t : r;\n  })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n  var t = _getRequireWildcardCache(r);\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n      __proto__: null\n    },\n    a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) {\n    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n  }\n  return n.default = e, t && t.set(e, n), n;\n}\nconst getActiveRoute = state => {\n  const route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n  return route;\n};\nconst cachedNormalizedConfigs = new WeakMap();\nconst getNormalizedConfigs = options => {\n  if (!options?.screens) return {};\n  const cached = cachedNormalizedConfigs.get(options?.screens);\n  if (cached) return cached;\n  const normalizedConfigs = createNormalizedConfigs(options.screens);\n  cachedNormalizedConfigs.set(options.screens, normalizedConfigs);\n  return normalizedConfigs;\n};\nfunction getPathFromState(state, options) {\n  if (state == null) {\n    throw Error(`Got '${String(state)}' for the navigation state. You must pass a valid state object.`);\n  }\n  if (options) {\n    (0, _validatePathConfig.validatePathConfig)(options);\n  }\n  const configs = getNormalizedConfigs(options);\n  let path = '/';\n  let current = state;\n  const allParams = {};\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index];\n    let parts;\n    let focusedParams;\n    let currentOptions = configs;\n    const focusedRoute = getActiveRoute(state);\n    const nestedRouteNames = [];\n    let hasNext = true;\n    while (route.name in currentOptions && hasNext) {\n      parts = currentOptions[route.name].parts;\n      nestedRouteNames.push(route.name);\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n        const currentParams = Object.fromEntries(Object.entries(route.params).map(([key, value]) => [key, stringify?.[key] ? stringify[key](value) : String(value)]));\n        if (parts?.length) {\n          Object.assign(allParams, currentParams);\n        }\n        if (focusedRoute === route) {\n          focusedParams = Object.assign({}, currentParams);\n          parts?.forEach(({\n            param\n          }) => {\n            if (param) {\n              if (focusedParams) {\n                delete focusedParams[param];\n              }\n            }\n          });\n        }\n      }\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          hasNext = false;\n        }\n      }\n    }\n    if (currentOptions[route.name] !== undefined) {\n      path += parts?.map(({\n        segment,\n        param,\n        optional\n      }) => {\n        if (segment === '*') {\n          return route.name;\n        }\n        if (param) {\n          const value = allParams[param];\n          if (value === undefined && optional) {\n            return '';\n          }\n          return String(value).replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g, char => encodeURIComponent(char));\n        }\n        return encodeURIComponent(segment);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n    if (!focusedParams && focusedRoute.params) {\n      focusedParams = Object.fromEntries(Object.entries(focusedRoute.params).map(([key, value]) => [key, String(value)]));\n    }\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (const param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          delete focusedParams[param];\n        }\n      }\n      const query = queryString.stringify(focusedParams, {\n        sort: false\n      });\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n    current = route.state;\n  }\n  if (options?.path) {\n    path = `${options.path}/${path}`;\n  }\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n  if (!path.startsWith('/')) {\n    path = `/${path}`;\n  }\n  return path;\n}\nconst createConfigItem = (config, parentParts) => {\n  if (typeof config === 'string') {\n    const parts = (0, _getPatternParts.getPatternParts)(config);\n    if (parentParts) {\n      return {\n        parts: [...parentParts, ...parts]\n      };\n    }\n    return {\n      parts\n    };\n  }\n  if (config.exact && config.path === undefined) {\n    throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n  }\n  const parts = config.exact !== true ? [...(parentParts || []), ...(config.path ? (0, _getPatternParts.getPatternParts)(config.path) : [])] : config.path ? (0, _getPatternParts.getPatternParts)(config.path) : undefined;\n  const screens = config.screens ? createNormalizedConfigs(config.screens, parts) : undefined;\n  return {\n    parts,\n    stringify: config.stringify,\n    screens\n  };\n};\nconst createNormalizedConfigs = (options, parts) => Object.fromEntries(Object.entries(options).map(([name, c]) => {\n  const result = createConfigItem(c, parts);\n  return [name, result];\n}));","map":{"version":3,"names":["queryString","_interopRequireWildcard","require","_getPatternParts","_validatePathConfig","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","getActiveRoute","state","route","index","routes","length","cachedNormalizedConfigs","getNormalizedConfigs","options","screens","cached","normalizedConfigs","createNormalizedConfigs","getPathFromState","Error","String","validatePathConfig","configs","path","current","allParams","parts","focusedParams","currentOptions","focusedRoute","nestedRouteNames","hasNext","name","push","params","stringify","currentParams","fromEntries","entries","map","key","value","assign","forEach","param","undefined","nextRoute","nestedConfig","segment","optional","replace","char","encodeURIComponent","join","query","sort","startsWith","createConfigItem","config","parentParts","getPatternParts","exact","c","result"],"sources":["C:\\Users\\chauv\\Desktop\\holberton-demoday\\Safe-Cook\\SafeCook_0\\node_modules\\@react-navigation\\core\\src\\getPathFromState.tsx"],"sourcesContent":["import type {\r\n  NavigationState,\r\n  PartialState,\r\n  Route,\r\n} from '@react-navigation/routers';\r\nimport * as queryString from 'query-string';\r\n\r\nimport { getPatternParts, type PatternPart } from './getPatternParts';\r\nimport type { PathConfig, PathConfigMap } from './types';\r\nimport { validatePathConfig } from './validatePathConfig';\r\n\r\ntype Options<ParamList extends {}> = {\r\n  path?: string;\r\n  initialRouteName?: string;\r\n  screens: PathConfigMap<ParamList>;\r\n};\r\n\r\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\r\n\r\ntype StringifyConfig = Record<string, (value: unknown) => string>;\r\n\r\ntype ConfigItem = {\r\n  parts?: PatternPart[];\r\n  stringify?: StringifyConfig;\r\n  screens?: Record<string, ConfigItem>;\r\n};\r\n\r\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\r\n  const route =\r\n    typeof state.index === 'number'\r\n      ? state.routes[state.index]\r\n      : state.routes[state.routes.length - 1];\r\n\r\n  if (route.state) {\r\n    return getActiveRoute(route.state);\r\n  }\r\n\r\n  return route;\r\n};\r\n\r\nconst cachedNormalizedConfigs = new WeakMap<\r\n  PathConfigMap<{}>,\r\n  Record<string, ConfigItem>\r\n>();\r\n\r\nconst getNormalizedConfigs = (options?: Options<{}>) => {\r\n  if (!options?.screens) return {};\r\n\r\n  const cached = cachedNormalizedConfigs.get(options?.screens);\r\n\r\n  if (cached) return cached;\r\n\r\n  const normalizedConfigs = createNormalizedConfigs(options.screens);\r\n\r\n  cachedNormalizedConfigs.set(options.screens, normalizedConfigs);\r\n\r\n  return normalizedConfigs;\r\n};\r\n\r\n/**\r\n * Utility to serialize a navigation state object to a path string.\r\n *\r\n * @example\r\n * ```js\r\n * getPathFromState(\r\n *   {\r\n *     routes: [\r\n *       {\r\n *         name: 'Chat',\r\n *         params: { author: 'Jane', id: 42 },\r\n *       },\r\n *     ],\r\n *   },\r\n *   {\r\n *     screens: {\r\n *       Chat: {\r\n *         path: 'chat/:author/:id',\r\n *         stringify: { author: author => author.toLowerCase() }\r\n *       }\r\n *     }\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @param state Navigation state to serialize.\r\n * @param options Extra options to fine-tune how to serialize the path.\r\n * @returns Path representing the state, e.g. /foo/bar?count=42.\r\n */\r\nexport function getPathFromState<ParamList extends {}>(\r\n  state: State,\r\n  options?: Options<ParamList>\r\n): string {\r\n  if (state == null) {\r\n    throw Error(\r\n      `Got '${String(state)}' for the navigation state. You must pass a valid state object.`\r\n    );\r\n  }\r\n\r\n  if (options) {\r\n    validatePathConfig(options);\r\n  }\r\n\r\n  const configs = getNormalizedConfigs(options);\r\n\r\n  let path = '/';\r\n  let current: State | undefined = state;\r\n\r\n  const allParams: Record<string, string> = {};\r\n\r\n  while (current) {\r\n    let index = typeof current.index === 'number' ? current.index : 0;\r\n    let route = current.routes[index] as Route<string> & {\r\n      state?: State;\r\n    };\r\n\r\n    let parts: PatternPart[] | undefined;\r\n\r\n    let focusedParams: Record<string, string> | undefined;\r\n    let currentOptions = configs;\r\n\r\n    const focusedRoute = getActiveRoute(state);\r\n\r\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\r\n    const nestedRouteNames = [];\r\n\r\n    let hasNext = true;\r\n\r\n    while (route.name in currentOptions && hasNext) {\r\n      parts = currentOptions[route.name].parts;\r\n\r\n      nestedRouteNames.push(route.name);\r\n\r\n      if (route.params) {\r\n        const stringify = currentOptions[route.name]?.stringify;\r\n\r\n        const currentParams = Object.fromEntries(\r\n          Object.entries(route.params).map(([key, value]) => [\r\n            key,\r\n            stringify?.[key] ? stringify[key](value) : String(value),\r\n          ])\r\n        );\r\n\r\n        if (parts?.length) {\r\n          Object.assign(allParams, currentParams);\r\n        }\r\n\r\n        if (focusedRoute === route) {\r\n          // If this is the focused route, keep the params for later use\r\n          // We save it here since it's been stringified already\r\n          focusedParams = { ...currentParams };\r\n\r\n          parts\r\n            // eslint-disable-next-line no-loop-func\r\n            ?.forEach(({ param }) => {\r\n              if (param) {\r\n                // Remove the params present in the pattern since we'll only use the rest for query string\r\n                if (focusedParams) {\r\n                  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\r\n                  delete focusedParams[param];\r\n                }\r\n              }\r\n            });\r\n        }\r\n      }\r\n\r\n      // If there is no `screens` property or no nested state, we return pattern\r\n      if (!currentOptions[route.name].screens || route.state === undefined) {\r\n        hasNext = false;\r\n      } else {\r\n        index =\r\n          typeof route.state.index === 'number'\r\n            ? route.state.index\r\n            : route.state.routes.length - 1;\r\n\r\n        const nextRoute = route.state.routes[index];\r\n        const nestedConfig = currentOptions[route.name].screens;\r\n\r\n        // if there is config for next route name, we go deeper\r\n        if (nestedConfig && nextRoute.name in nestedConfig) {\r\n          route = nextRoute as Route<string> & { state?: State };\r\n          currentOptions = nestedConfig;\r\n        } else {\r\n          // If not, there is no sense in going deeper in config\r\n          hasNext = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (currentOptions[route.name] !== undefined) {\r\n      path += parts\r\n        ?.map(({ segment, param, optional }) => {\r\n          // We don't know what to show for wildcard patterns\r\n          // Showing the route name seems ok, though whatever we show here will be incorrect\r\n          // Since the page doesn't actually exist\r\n          if (segment === '*') {\r\n            return route.name;\r\n          }\r\n\r\n          // If the path has a pattern for a param, put the param in the path\r\n          if (param) {\r\n            const value = allParams[param];\r\n\r\n            if (value === undefined && optional) {\r\n              // Optional params without value assigned in route.params should be ignored\r\n              return '';\r\n            }\r\n\r\n            // Valid characters according to\r\n            // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)\r\n            return String(value).replace(\r\n              /[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g,\r\n              (char) => encodeURIComponent(char)\r\n            );\r\n          }\r\n\r\n          return encodeURIComponent(segment);\r\n        })\r\n        .join('/');\r\n    } else {\r\n      path += encodeURIComponent(route.name);\r\n    }\r\n\r\n    if (!focusedParams && focusedRoute.params) {\r\n      focusedParams = Object.fromEntries(\r\n        Object.entries(focusedRoute.params).map(([key, value]) => [\r\n          key,\r\n          String(value),\r\n        ])\r\n      );\r\n    }\r\n\r\n    if (route.state) {\r\n      path += '/';\r\n    } else if (focusedParams) {\r\n      for (const param in focusedParams) {\r\n        if (focusedParams[param] === 'undefined') {\r\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\r\n          delete focusedParams[param];\r\n        }\r\n      }\r\n\r\n      const query = queryString.stringify(focusedParams, { sort: false });\r\n\r\n      if (query) {\r\n        path += `?${query}`;\r\n      }\r\n    }\r\n\r\n    current = route.state;\r\n  }\r\n\r\n  // Include the root path if specified\r\n  if (options?.path) {\r\n    path = `${options.path}/${path}`;\r\n  }\r\n\r\n  // Remove multiple as well as trailing slashes\r\n  path = path.replace(/\\/+/g, '/');\r\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\r\n\r\n  // If path doesn't start with a slash, add it\r\n  // This makes sure that history.pushState will update the path correctly instead of appending\r\n  if (!path.startsWith('/')) {\r\n    path = `/${path}`;\r\n  }\r\n\r\n  return path;\r\n}\r\n\r\nconst createConfigItem = (\r\n  config: PathConfig<object> | string,\r\n  parentParts?: PatternPart[]\r\n): ConfigItem => {\r\n  if (typeof config === 'string') {\r\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\r\n    const parts = getPatternParts(config);\r\n\r\n    if (parentParts) {\r\n      return { parts: [...parentParts, ...parts] };\r\n    }\r\n\r\n    return { parts };\r\n  }\r\n\r\n  if (config.exact && config.path === undefined) {\r\n    throw new Error(\r\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\r\n    );\r\n  }\r\n\r\n  // If an object is specified as the value (e.g. Foo: { ... }),\r\n  // It can have `path` property and `screens` prop which has nested configs\r\n  const parts =\r\n    config.exact !== true\r\n      ? [\r\n          ...(parentParts || []),\r\n          ...(config.path ? getPatternParts(config.path) : []),\r\n        ]\r\n      : config.path\r\n        ? getPatternParts(config.path)\r\n        : undefined;\r\n\r\n  const screens = config.screens\r\n    ? createNormalizedConfigs(config.screens, parts)\r\n    : undefined;\r\n\r\n  return {\r\n    parts,\r\n    stringify: config.stringify,\r\n    screens,\r\n  };\r\n};\r\n\r\nconst createNormalizedConfigs = (\r\n  options: PathConfigMap<object>,\r\n  parts?: PatternPart[]\r\n): Record<string, ConfigItem> =>\r\n  Object.fromEntries(\r\n    Object.entries(options).map(([name, c]) => {\r\n      const result = createConfigItem(c, parts);\r\n\r\n      return [name, result];\r\n    })\r\n  );\r\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}