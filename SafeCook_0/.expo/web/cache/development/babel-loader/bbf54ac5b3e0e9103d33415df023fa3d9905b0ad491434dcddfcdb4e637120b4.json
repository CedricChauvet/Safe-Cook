{"ast":null,"code":"\"use strict\";\n\nvar _objectWithoutPropertiesLoose = require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\");\nconst _excluded = [\"screen\", \"if\"],\n  _excluded2 = [\"screens\", \"groups\"],\n  _excluded3 = [\"if\"];\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createComponentForStaticNavigation = createComponentForStaticNavigation;\nexports.createPathConfigForStaticNavigation = createPathConfigForStaticNavigation;\nvar _react = _interopRequireWildcard(require(\"react\"));\nvar React = _react;\nvar _reactIs = require(\"react-is\");\nvar _useRoute = require(\"./useRoute.js\");\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof WeakMap) return null;\n  var r = new WeakMap(),\n    t = new WeakMap();\n  return (_getRequireWildcardCache = function (e) {\n    return e ? t : r;\n  })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n  var t = _getRequireWildcardCache(r);\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n      __proto__: null\n    },\n    a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) {\n    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n  }\n  return n.default = e, t && t.set(e, n), n;\n}\nconst MemoizedScreen = React.memo(({\n  component\n}) => {\n  const route = (0, _useRoute.useRoute)();\n  const children = React.createElement(component, {\n    route\n  });\n  return children;\n});\nMemoizedScreen.displayName = 'Memo(Screen)';\nconst getItemsFromScreens = (Screen, screens) => {\n  return Object.entries(screens).map(([name, item]) => {\n    let component;\n    let props = {};\n    let useIf;\n    let isNavigator = false;\n    if ('screen' in item) {\n      const {\n          screen,\n          if: _if\n        } = item,\n        rest = _objectWithoutPropertiesLoose(item, _excluded);\n      useIf = _if;\n      props = rest;\n      if ((0, _reactIs.isValidElementType)(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(screen, `${name}Navigator`);\n      }\n    } else if ((0, _reactIs.isValidElementType)(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n    if (component == null) {\n      throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);\n    }\n    const element = isNavigator ? (React.createElement(component, {})) : (0, _jsxRuntime.jsx)(MemoizedScreen, {\n      component: component\n    });\n    return () => {\n      const shouldRender = useIf == null || useIf();\n      if (!shouldRender) {\n        return null;\n      }\n      return (0, _jsxRuntime.jsx)(Screen, Object.assign({\n        name: name\n      }, props, {\n        children: () => element\n      }), name);\n    };\n  });\n};\nfunction createComponentForStaticNavigation(tree, displayName) {\n  const {\n    Navigator,\n    Group,\n    Screen,\n    config\n  } = tree;\n  const {\n      screens,\n      groups\n    } = config,\n    rest = _objectWithoutPropertiesLoose(config, _excluded2);\n  if (screens == null && groups == null) {\n    throw new Error(\"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\");\n  }\n  const items = [];\n  for (const key in config) {\n    if (key === 'screens' && screens) {\n      items.push(...getItemsFromScreens(Screen, screens));\n    }\n    if (key === 'groups' && groups) {\n      items.push(...Object.entries(groups).map(([key, _ref]) => {\n        let {\n            if: useIf\n          } = _ref,\n          group = _objectWithoutPropertiesLoose(_ref, _excluded3);\n        const groupItems = getItemsFromScreens(Screen, group.screens);\n        return () => {\n          const children = groupItems.map(item => item());\n          const shouldRender = useIf == null || useIf();\n          if (!shouldRender) {\n            return null;\n          }\n          return (0, _react.createElement)(Group, Object.assign({\n            navigationKey: key\n          }, group, {\n            key: key\n          }), children);\n        };\n      }));\n    }\n  }\n  const NavigatorComponent = () => {\n    const children = items.map(item => item());\n    return (0, _jsxRuntime.jsx)(Navigator, Object.assign({}, rest, {\n      children: children\n    }));\n  };\n  NavigatorComponent.displayName = displayName;\n  return NavigatorComponent;\n}\nfunction createPathConfigForStaticNavigation(tree, options, auto) {\n  let initialScreenConfig;\n  const createPathConfigForTree = (t, o, skipInitialDetection) => {\n    const createPathConfigForScreens = (screens, initialRouteName) => {\n      return Object.fromEntries(Object.entries(screens).sort(([a], [b]) => {\n        if (a === initialRouteName) {\n          return -1;\n        }\n        if (b === initialRouteName) {\n          return 1;\n        }\n        return 0;\n      }).map(([key, item]) => {\n        const screenConfig = {};\n        if ('linking' in item) {\n          if (typeof item.linking === 'string') {\n            screenConfig.path = item.linking;\n          } else {\n            Object.assign(screenConfig, item.linking);\n          }\n          if (typeof screenConfig.path === 'string') {\n            screenConfig.path = screenConfig.path.split('/').filter(Boolean).join('/');\n          }\n        }\n        let screens;\n        const skipInitialDetectionInChild = skipInitialDetection || screenConfig.path != null && screenConfig.path !== '';\n        if ('config' in item) {\n          screens = createPathConfigForTree(item, undefined, skipInitialDetectionInChild);\n        } else if ('screen' in item && 'config' in item.screen && (item.screen.config.screens || item.screen.config.groups)) {\n          screens = createPathConfigForTree(item.screen, undefined, skipInitialDetectionInChild);\n        }\n        if (screens) {\n          screenConfig.screens = screens;\n        }\n        if (auto && !screenConfig.screens && !('linking' in item && item.linking == null)) {\n          if (screenConfig.path != null) {\n            if (!skipInitialDetection && screenConfig.path === '') {\n              initialScreenConfig = undefined;\n            }\n          } else {\n            if (!skipInitialDetection && initialScreenConfig == null) {\n              initialScreenConfig = screenConfig;\n            }\n            screenConfig.path = key.replace(/([A-Z]+)/g, '-$1').replace(/^-/, '').toLowerCase();\n          }\n        }\n        return [key, screenConfig];\n      }).filter(([, screen]) => Object.keys(screen).length > 0));\n    };\n    const screens = {};\n    for (const key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        Object.assign(screens, createPathConfigForScreens(t.config.screens, o?.initialRouteName ?? t.config.initialRouteName));\n      }\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(([, group]) => {\n          Object.assign(screens, createPathConfigForScreens(group.screens, o?.initialRouteName ?? t.config.initialRouteName));\n        });\n      }\n    }\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n    return screens;\n  };\n  const screens = createPathConfigForTree(tree, options, false);\n  if (auto && initialScreenConfig) {\n    initialScreenConfig.path = '';\n  }\n  return screens;\n}","map":{"version":3,"names":["_react","_interopRequireWildcard","require","React","_reactIs","_useRoute","_jsxRuntime","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","MemoizedScreen","memo","component","route","useRoute","children","createElement","displayName","getItemsFromScreens","Screen","screens","entries","map","name","item","props","useIf","isNavigator","screen","if","_if","rest","_objectWithoutPropertiesLoose","_excluded","isValidElementType","createComponentForStaticNavigation","Error","element","jsx","shouldRender","assign","tree","Navigator","Group","config","groups","_excluded2","items","key","push","_ref","group","_excluded3","groupItems","navigationKey","NavigatorComponent","createPathConfigForStaticNavigation","options","auto","initialScreenConfig","createPathConfigForTree","o","skipInitialDetection","createPathConfigForScreens","initialRouteName","fromEntries","sort","b","screenConfig","linking","path","split","filter","Boolean","join","skipInitialDetectionInChild","undefined","replace","toLowerCase","keys","length","forEach"],"sources":["C:\\Users\\chauv\\Desktop\\holberton-demoday\\Safe-Cook\\SafeCook_0\\node_modules\\@react-navigation\\core\\src\\StaticNavigation.tsx"],"sourcesContent":["import type { NavigationState, ParamListBase } from '@react-navigation/routers';\r\nimport * as React from 'react';\r\nimport { isValidElementType } from 'react-is';\r\n\r\nimport type {\r\n  DefaultNavigatorOptions,\r\n  EventMapBase,\r\n  NavigationListBase,\r\n  NavigatorScreenParams,\r\n  NavigatorTypeBagBase,\r\n  PathConfig,\r\n  RouteConfigComponent,\r\n  RouteConfigProps,\r\n  RouteGroupConfig,\r\n} from './types';\r\nimport { useRoute } from './useRoute';\r\n\r\n/**\r\n * Flatten a type to remove all type alias names, unions etc.\r\n * This will show a plain object when hovering over the type.\r\n */\r\ntype FlatType<T> = { [K in keyof T]: T[K] } & {};\r\n\r\n/**\r\n * keyof T doesn't work for union types. We can use distributive conditional types instead.\r\n * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\r\n */\r\ntype KeysOf<T> = T extends {} ? keyof T : never;\r\n\r\n/**\r\n * We get a union type when using keyof, but we want an intersection instead.\r\n * https://stackoverflow.com/a/50375286/1665026\r\n */\r\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\r\n  k: infer I\r\n) => void\r\n  ? I\r\n  : never;\r\n\r\ntype UnknownToUndefined<T> = unknown extends T ? undefined : T;\r\n\r\ntype ParamsForScreenComponent<T> = T extends {\r\n  screen: React.ComponentType<{ route: { params: infer P } }>;\r\n}\r\n  ? P\r\n  : T extends React.ComponentType<{ route: { params: infer P } }>\r\n    ? P\r\n    : undefined;\r\n\r\ntype ParamsForScreen<T> = T extends { screen: StaticNavigation<any, any, any> }\r\n  ? NavigatorScreenParams<StaticParamList<T['screen']>> | undefined\r\n  : T extends StaticNavigation<any, any, any>\r\n    ? NavigatorScreenParams<StaticParamList<T>> | undefined\r\n    : UnknownToUndefined<ParamsForScreenComponent<T>>;\r\n\r\ntype ParamListForScreens<Screens> = {\r\n  [Key in KeysOf<Screens>]: ParamsForScreen<Screens[Key]>;\r\n};\r\n\r\ntype ParamListForGroups<\r\n  Groups extends\r\n    | Readonly<{\r\n        [key: string]: {\r\n          screens: StaticConfigScreens<\r\n            ParamListBase,\r\n            NavigationState,\r\n            {},\r\n            EventMapBase,\r\n            any\r\n          >;\r\n        };\r\n      }>\r\n    | undefined,\r\n> = Groups extends {\r\n  [key: string]: {\r\n    screens: StaticConfigScreens<\r\n      ParamListBase,\r\n      NavigationState,\r\n      {},\r\n      EventMapBase,\r\n      any\r\n    >;\r\n  };\r\n}\r\n  ? ParamListForScreens<UnionToIntersection<Groups[keyof Groups]['screens']>>\r\n  : {};\r\n\r\ntype StaticRouteConfig<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase,\r\n  Navigation,\r\n> = RouteConfigProps<\r\n  ParamList,\r\n  RouteName,\r\n  State,\r\n  ScreenOptions,\r\n  EventMap,\r\n  Navigation\r\n> &\r\n  RouteConfigComponent<ParamList, RouteName>;\r\n\r\ntype StaticConfigScreens<\r\n  ParamList extends ParamListBase,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase,\r\n  NavigationList extends NavigationListBase<ParamList>,\r\n> = {\r\n  [RouteName in keyof ParamList]:\r\n    | React.ComponentType<any>\r\n    | StaticNavigation<any, any, any>\r\n    | (Omit<\r\n        StaticRouteConfig<\r\n          ParamList,\r\n          RouteName,\r\n          State,\r\n          ScreenOptions,\r\n          EventMap,\r\n          NavigationList[RouteName]\r\n        >,\r\n        'name' | 'component' | 'getComponent' | 'children'\r\n      > & {\r\n        /**\r\n         * Callback to determine whether the screen should be rendered or not.\r\n         * This can be useful for conditional rendering of screens,\r\n         * e.g. - if you want to render a different screen for logged in users.\r\n         *\r\n         * You can use a custom hook to use custom logic to determine the return value.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * if: useIsLoggedIn\r\n         * ```\r\n         */\r\n        if?: () => boolean;\r\n        /**\r\n         * Linking config for the screen.\r\n         * This can be a string to specify the path, or an object with more options.\r\n         *\r\n         * @example\r\n         * ```js\r\n         * linking: {\r\n         *   path: 'profile/:id',\r\n         *   exact: true,\r\n         * },\r\n         * ```\r\n         */\r\n        linking?: PathConfig<ParamList> | string;\r\n        /**\r\n         * Static navigation config or Component to render for the screen.\r\n         */\r\n        screen: StaticNavigation<any, any, any> | React.ComponentType<any>;\r\n      });\r\n};\r\n\r\ntype GroupConfig<\r\n  ParamList extends ParamListBase,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase,\r\n  NavigationList extends NavigationListBase<ParamList>,\r\n> = Omit<\r\n  RouteGroupConfig<ParamList, ScreenOptions, NavigationList[keyof ParamList]>,\r\n  'screens' | 'children'\r\n> & {\r\n  /**\r\n   * Callback to determine whether the screens in the group should be rendered or not.\r\n   * This can be useful for conditional rendering of group of screens.\r\n   */\r\n  if?: () => boolean;\r\n  /**\r\n   * Static navigation config or Component to render for the screen.\r\n   */\r\n  screens: StaticConfigScreens<\r\n    ParamList,\r\n    State,\r\n    ScreenOptions,\r\n    EventMap,\r\n    NavigationList\r\n  >;\r\n};\r\n\r\nexport type StaticConfig<Bag extends NavigatorTypeBagBase> =\r\n  StaticConfigInternal<\r\n    Bag['ParamList'],\r\n    Bag['NavigatorID'],\r\n    Bag['State'],\r\n    Bag['ScreenOptions'],\r\n    Bag['EventMap'],\r\n    Bag['NavigationList'],\r\n    Bag['Navigator']\r\n  >;\r\n\r\ntype StaticConfigInternal<\r\n  ParamList extends ParamListBase,\r\n  NavigatorID extends string | undefined,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase,\r\n  NavigationList extends NavigationListBase<ParamList>,\r\n  Navigator extends React.ComponentType<any>,\r\n> = Omit<\r\n  Omit<\r\n    React.ComponentProps<Navigator>,\r\n    keyof DefaultNavigatorOptions<\r\n      ParamListBase,\r\n      string | undefined,\r\n      NavigationState,\r\n      {},\r\n      EventMapBase,\r\n      NavigationList[keyof ParamList]\r\n    >\r\n  > &\r\n    DefaultNavigatorOptions<\r\n      ParamList,\r\n      NavigatorID,\r\n      State,\r\n      ScreenOptions,\r\n      EventMap,\r\n      NavigationList[keyof ParamList]\r\n    >,\r\n  'screens' | 'children'\r\n> &\r\n  (\r\n    | {\r\n        /**\r\n         * Screens to render in the navigator and their configuration.\r\n         */\r\n        screens: StaticConfigScreens<\r\n          ParamList,\r\n          State,\r\n          ScreenOptions,\r\n          EventMap,\r\n          NavigationList\r\n        >;\r\n        /**\r\n         * Groups of screens to render in the navigator and their configuration.\r\n         */\r\n        groups?: {\r\n          [key: string]: GroupConfig<\r\n            ParamList,\r\n            State,\r\n            ScreenOptions,\r\n            EventMap,\r\n            NavigationList\r\n          >;\r\n        };\r\n      }\r\n    | {\r\n        /**\r\n         * Screens to render in the navigator and their configuration.\r\n         */\r\n        screens?: StaticConfigScreens<\r\n          ParamList,\r\n          State,\r\n          ScreenOptions,\r\n          EventMap,\r\n          NavigationList\r\n        >;\r\n        /**\r\n         * Groups of screens to render in the navigator and their configuration.\r\n         */\r\n        groups: {\r\n          [key: string]: GroupConfig<\r\n            ParamList,\r\n            State,\r\n            ScreenOptions,\r\n            EventMap,\r\n            NavigationList\r\n          >;\r\n        };\r\n      }\r\n  );\r\n\r\n/**\r\n * Props for a screen component which is rendered by a static navigator.\r\n * Takes the route params as a generic argument.\r\n */\r\nexport type StaticScreenProps<T extends Record<string, unknown> | undefined> = {\r\n  route: {\r\n    params: T;\r\n  };\r\n};\r\n\r\n/**\r\n * Infer the param list from the static navigation config.\r\n */\r\nexport type StaticParamList<\r\n  T extends {\r\n    readonly config: {\r\n      readonly screens?: Record<string, any>;\r\n      readonly groups?: {\r\n        [key: string]: {\r\n          screens: Record<string, any>;\r\n        };\r\n      };\r\n    };\r\n  },\r\n> = FlatType<\r\n  ParamListForScreens<T['config']['screens']> &\r\n    ParamListForGroups<T['config']['groups']>\r\n>;\r\n\r\nexport type StaticNavigation<NavigatorProps, GroupProps, ScreenProps> = {\r\n  Navigator: React.ComponentType<NavigatorProps>;\r\n  Group: React.ComponentType<GroupProps>;\r\n  Screen: React.ComponentType<ScreenProps>;\r\n  config: StaticConfig<NavigatorTypeBagBase>;\r\n};\r\n\r\nconst MemoizedScreen = React.memo(\r\n  <T extends React.ComponentType<any>>({ component }: { component: T }) => {\r\n    const route = useRoute();\r\n    const children = React.createElement(component, { route });\r\n\r\n    return children;\r\n  }\r\n);\r\n\r\nMemoizedScreen.displayName = 'Memo(Screen)';\r\n\r\nconst getItemsFromScreens = (\r\n  Screen: React.ComponentType<any>,\r\n  screens: StaticConfigScreens<any, any, any, any, any>\r\n) => {\r\n  return Object.entries(screens).map(([name, item]) => {\r\n    let component: React.ComponentType<any> | undefined;\r\n    let props: {} = {};\r\n    let useIf: (() => boolean) | undefined;\r\n\r\n    let isNavigator = false;\r\n\r\n    if ('screen' in item) {\r\n      const { screen, if: _if, ...rest } = item;\r\n\r\n      useIf = _if;\r\n      props = rest;\r\n\r\n      if (isValidElementType(screen)) {\r\n        component = screen;\r\n      } else if ('config' in screen) {\r\n        isNavigator = true;\r\n        component = createComponentForStaticNavigation(\r\n          screen,\r\n          `${name}Navigator`\r\n        );\r\n      }\r\n    } else if (isValidElementType(item)) {\r\n      component = item;\r\n    } else if ('config' in item) {\r\n      isNavigator = true;\r\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\r\n    }\r\n\r\n    if (component == null) {\r\n      throw new Error(\r\n        `Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`\r\n      );\r\n    }\r\n\r\n    const element = isNavigator ? (\r\n      React.createElement(component, {})\r\n    ) : (\r\n      <MemoizedScreen component={component} />\r\n    );\r\n\r\n    return () => {\r\n      const shouldRender = useIf == null || useIf();\r\n\r\n      if (!shouldRender) {\r\n        return null;\r\n      }\r\n\r\n      return (\r\n        <Screen key={name} name={name} {...props}>\r\n          {() => element}\r\n        </Screen>\r\n      );\r\n    };\r\n  });\r\n};\r\n\r\n/**\r\n * Create a component that renders a navigator based on the static configuration.\r\n *\r\n * @param tree Static navigation config.\r\n * @param displayName Name of the component to be displayed in React DevTools.\r\n * @returns A component which renders the navigator.\r\n */\r\nexport function createComponentForStaticNavigation(\r\n  tree: StaticNavigation<any, any, any>,\r\n  displayName: string\r\n): React.ComponentType<{}> {\r\n  const { Navigator, Group, Screen, config } = tree;\r\n  const { screens, groups, ...rest } = config;\r\n\r\n  if (screens == null && groups == null) {\r\n    throw new Error(\r\n      \"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\"\r\n    );\r\n  }\r\n\r\n  const items: (() => JSX.Element | null)[] = [];\r\n\r\n  // Loop through the config to find screens and groups\r\n  // So we add the screens and groups in the same order as they are defined\r\n  for (const key in config) {\r\n    if (key === 'screens' && screens) {\r\n      items.push(...getItemsFromScreens(Screen, screens));\r\n    }\r\n\r\n    if (key === 'groups' && groups) {\r\n      items.push(\r\n        ...Object.entries(groups).map(([key, { if: useIf, ...group }]) => {\r\n          const groupItems = getItemsFromScreens(Screen, group.screens);\r\n\r\n          return () => {\r\n            // Call unconditionally since screen configs may contain `useIf` hooks\r\n            const children = groupItems.map((item) => item());\r\n\r\n            const shouldRender = useIf == null || useIf();\r\n\r\n            if (!shouldRender) {\r\n              return null;\r\n            }\r\n\r\n            return (\r\n              <Group navigationKey={key} {...group} key={key}>\r\n                {children}\r\n              </Group>\r\n            );\r\n          };\r\n        })\r\n      );\r\n    }\r\n  }\r\n\r\n  const NavigatorComponent = () => {\r\n    const children = items.map((item) => item());\r\n\r\n    return <Navigator {...rest}>{children}</Navigator>;\r\n  };\r\n\r\n  NavigatorComponent.displayName = displayName;\r\n\r\n  return NavigatorComponent;\r\n}\r\n\r\ntype TreeForPathConfig = {\r\n  config: {\r\n    initialRouteName?: string;\r\n    screens?: StaticConfigScreens<\r\n      ParamListBase,\r\n      NavigationState,\r\n      {},\r\n      EventMapBase,\r\n      Record<string, unknown>\r\n    >;\r\n    groups?: {\r\n      [key: string]: {\r\n        screens: StaticConfigScreens<\r\n          ParamListBase,\r\n          NavigationState,\r\n          {},\r\n          EventMapBase,\r\n          Record<string, unknown>\r\n        >;\r\n      };\r\n    };\r\n  };\r\n};\r\n\r\n/**\r\n * Create a path config object from a static navigation config for deep linking.\r\n *\r\n * @param tree Static navigation config.\r\n * @param options Additional options from `linking.config`.\r\n * @param auto Whether to automatically generate paths for leaf screens.\r\n * @returns Path config object to use in linking config.\r\n *\r\n * @example\r\n * ```js\r\n * const config = {\r\n *   screens: {\r\n *     Home: {\r\n *       screens: createPathConfigForStaticNavigation(HomeTabs),\r\n *     },\r\n *   },\r\n * };\r\n * ```\r\n */\r\nexport function createPathConfigForStaticNavigation(\r\n  tree: TreeForPathConfig,\r\n  options?: {\r\n    initialRouteName?: string;\r\n  },\r\n  auto?: boolean\r\n) {\r\n  let initialScreenConfig: PathConfig<ParamListBase> | undefined;\r\n\r\n  const createPathConfigForTree = (\r\n    t: TreeForPathConfig,\r\n    o: { initialRouteName?: string } | undefined,\r\n    // If a screen is a leaf node, but inside a screen with path,\r\n    // It should not be used for initial detection\r\n    skipInitialDetection: boolean\r\n  ) => {\r\n    const createPathConfigForScreens = (\r\n      screens: StaticConfigScreens<\r\n        ParamListBase,\r\n        NavigationState,\r\n        {},\r\n        EventMapBase,\r\n        Record<string, unknown>\r\n      >,\r\n      initialRouteName: string | undefined\r\n    ) => {\r\n      return Object.fromEntries(\r\n        Object.entries(screens)\r\n          // Re-order to move the initial route to the front\r\n          // This way we can detect the initial route correctly\r\n          .sort(([a], [b]) => {\r\n            if (a === initialRouteName) {\r\n              return -1;\r\n            }\r\n\r\n            if (b === initialRouteName) {\r\n              return 1;\r\n            }\r\n\r\n            return 0;\r\n          })\r\n          .map(([key, item]) => {\r\n            const screenConfig: PathConfig<ParamListBase> = {};\r\n\r\n            if ('linking' in item) {\r\n              if (typeof item.linking === 'string') {\r\n                screenConfig.path = item.linking;\r\n              } else {\r\n                Object.assign(screenConfig, item.linking);\r\n              }\r\n\r\n              if (typeof screenConfig.path === 'string') {\r\n                // Normalize the path to remove leading and trailing slashes\r\n                screenConfig.path = screenConfig.path\r\n                  .split('/')\r\n                  .filter(Boolean)\r\n                  .join('/');\r\n              }\r\n            }\r\n\r\n            let screens;\r\n\r\n            const skipInitialDetectionInChild =\r\n              skipInitialDetection ||\r\n              (screenConfig.path != null && screenConfig.path !== '');\r\n\r\n            if ('config' in item) {\r\n              screens = createPathConfigForTree(\r\n                item,\r\n                undefined,\r\n                skipInitialDetectionInChild\r\n              );\r\n            } else if (\r\n              'screen' in item &&\r\n              'config' in item.screen &&\r\n              (item.screen.config.screens || item.screen.config.groups)\r\n            ) {\r\n              screens = createPathConfigForTree(\r\n                item.screen,\r\n                undefined,\r\n                skipInitialDetectionInChild\r\n              );\r\n            }\r\n\r\n            if (screens) {\r\n              screenConfig.screens = screens;\r\n            }\r\n\r\n            if (\r\n              auto &&\r\n              !screenConfig.screens &&\r\n              // Skip generating path for screens that specify linking config as `undefined` or `null` explicitly\r\n              !('linking' in item && item.linking == null)\r\n            ) {\r\n              if (screenConfig.path != null) {\r\n                if (!skipInitialDetection && screenConfig.path === '') {\r\n                  // We encounter a leaf screen with empty path,\r\n                  // Clear the initial screen config as it's not needed anymore\r\n                  initialScreenConfig = undefined;\r\n                }\r\n              } else {\r\n                if (!skipInitialDetection && initialScreenConfig == null) {\r\n                  initialScreenConfig = screenConfig;\r\n                }\r\n\r\n                screenConfig.path = key\r\n                  .replace(/([A-Z]+)/g, '-$1')\r\n                  .replace(/^-/, '')\r\n                  .toLowerCase();\r\n              }\r\n            }\r\n\r\n            return [key, screenConfig] as const;\r\n          })\r\n          .filter(([, screen]) => Object.keys(screen).length > 0)\r\n      );\r\n    };\r\n\r\n    const screens = {};\r\n\r\n    // Loop through the config to find screens and groups\r\n    // So we add the screens and groups in the same order as they are defined\r\n    for (const key in t.config) {\r\n      if (key === 'screens' && t.config.screens) {\r\n        Object.assign(\r\n          screens,\r\n          createPathConfigForScreens(\r\n            t.config.screens,\r\n            o?.initialRouteName ?? t.config.initialRouteName\r\n          )\r\n        );\r\n      }\r\n\r\n      if (key === 'groups' && t.config.groups) {\r\n        Object.entries(t.config.groups).forEach(([, group]) => {\r\n          Object.assign(\r\n            screens,\r\n            createPathConfigForScreens(\r\n              group.screens,\r\n              o?.initialRouteName ?? t.config.initialRouteName\r\n            )\r\n          );\r\n        });\r\n      }\r\n    }\r\n\r\n    if (Object.keys(screens).length === 0) {\r\n      return undefined;\r\n    }\r\n\r\n    return screens;\r\n  };\r\n\r\n  const screens = createPathConfigForTree(tree, options, false);\r\n\r\n  if (auto && initialScreenConfig) {\r\n    initialScreenConfig.path = '';\r\n  }\r\n\r\n  return screens;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}