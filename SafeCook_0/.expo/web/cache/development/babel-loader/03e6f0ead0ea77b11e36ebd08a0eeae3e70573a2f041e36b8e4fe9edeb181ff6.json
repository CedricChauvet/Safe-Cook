{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PrivateValueStore = void 0;\nclass PrivateValueStore {}\nexports.PrivateValueStore = PrivateValueStore;","map":{"version":3,"names":["PrivateValueStore","exports"],"sources":["C:\\Users\\chauv\\Desktop\\holberton-demoday\\Safe-Cook\\SafeCook_0\\node_modules\\@react-navigation\\core\\src\\types.tsx"],"sourcesContent":["import type {\r\n  DefaultRouterOptions,\r\n  InitialState,\r\n  NavigationAction,\r\n  NavigationState,\r\n  ParamListBase,\r\n  PartialState,\r\n  Route,\r\n} from '@react-navigation/routers';\r\nimport type * as React from 'react';\r\n\r\ndeclare global {\r\n  // eslint-disable-next-line @typescript-eslint/no-namespace\r\n  namespace ReactNavigation {\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-interface\r\n    interface RootParamList {}\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-interface\r\n    interface Theme {}\r\n  }\r\n}\r\n\r\ntype Keyof<T extends {}> = Extract<keyof T, string>;\r\n\r\ntype ScreenParamsPair<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList,\r\n> = {\r\n  // First we use a mapped type to get an union of screen & params pairs\r\n  // Then we pick the pair which matches the RouteName\r\n  // Mapped type is used instead of just ParamList[RouteName]\r\n  // Otherwise it'll result in union of all params leading to incorrect types\r\n  [Screen in keyof ParamList]: undefined extends ParamList[Screen] // Params are either undefined or a union with undefined\r\n    ?\r\n        | [screen: Screen] // if the params are optional, we don't have to provide it\r\n        | [screen: Screen, params: ParamList[Screen]]\r\n    : [screen: Screen, params: ParamList[Screen]];\r\n}[RouteName];\r\n\r\nexport type DefaultNavigatorOptions<\r\n  ParamList extends ParamListBase,\r\n  NavigatorID extends string | undefined,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase,\r\n  Navigation,\r\n> = DefaultRouterOptions<Keyof<ParamList>> & {\r\n  /**\r\n   * Children React Elements to extract the route configuration from.\r\n   * Only `Screen`, `Group` and `React.Fragment` are supported as children.\r\n   */\r\n  children: React.ReactNode;\r\n\r\n  /**\r\n   * Layout for the navigator.\r\n   * Useful for wrapping with a component with access to navigator's state and options.\r\n   */\r\n  layout?: (props: {\r\n    state: State;\r\n    navigation: NavigationHelpers<ParamList>;\r\n    descriptors: Record<\r\n      string,\r\n      Descriptor<\r\n        ScreenOptions,\r\n        NavigationProp<\r\n          ParamList,\r\n          keyof ParamList,\r\n          string | undefined,\r\n          State,\r\n          ScreenOptions,\r\n          EventMap\r\n        >,\r\n        RouteProp<ParamList>\r\n      >\r\n    >;\r\n    children: React.ReactNode;\r\n  }) => React.ReactElement;\r\n\r\n  /**\r\n   * Event listeners for all the screens in the navigator.\r\n   */\r\n  screenListeners?:\r\n    | ScreenListeners<State, EventMap>\r\n    | ((props: {\r\n        route: RouteProp<ParamList>;\r\n        navigation: Navigation;\r\n      }) => ScreenListeners<State, EventMap>);\r\n\r\n  /**\r\n   * Default options for all screens under this navigator.\r\n   */\r\n  screenOptions?:\r\n    | ScreenOptions\r\n    | ((props: {\r\n        route: RouteProp<ParamList>;\r\n        navigation: Navigation;\r\n        theme: ReactNavigation.Theme;\r\n      }) => ScreenOptions);\r\n\r\n  /**\r\n   * Layout for all screens under this navigator.\r\n   */\r\n  screenLayout?: (props: {\r\n    route: RouteProp<ParamList, keyof ParamList>;\r\n    navigation: Navigation;\r\n    theme: ReactNavigation.Theme;\r\n    children: React.ReactElement;\r\n  }) => React.ReactElement;\r\n\r\n  /**\r\n   A function returning a state, which may be set after modifying the routes name.\r\n   */\r\n  UNSTABLE_getStateForRouteNamesChange?: (\r\n    state: NavigationState\r\n  ) => PartialState<NavigationState> | undefined;\r\n} & (NavigatorID extends string\r\n    ? {\r\n        /**\r\n         * Optional ID for the navigator. Can be used with `navigation.getParent(id)` to refer to a parent.\r\n         */\r\n        id: NavigatorID;\r\n      }\r\n    : {\r\n        id?: undefined;\r\n      });\r\n\r\nexport type EventMapBase = Record<\r\n  string,\r\n  { data?: any; canPreventDefault?: boolean }\r\n>;\r\n\r\nexport type EventMapCore<State extends NavigationState> = {\r\n  focus: { data: undefined };\r\n  blur: { data: undefined };\r\n  state: { data: { state: State } };\r\n  beforeRemove: { data: { action: NavigationAction }; canPreventDefault: true };\r\n};\r\n\r\nexport type EventArg<\r\n  EventName,\r\n  CanPreventDefault extends boolean | undefined = false,\r\n  Data = undefined,\r\n> = {\r\n  /**\r\n   * Type of the event (e.g. `focus`, `blur`)\r\n   */\r\n  readonly type: EventName;\r\n  readonly target?: string;\r\n} & (CanPreventDefault extends true\r\n  ? {\r\n      /**\r\n       * Whether `event.preventDefault()` was called on this event object.\r\n       */\r\n      readonly defaultPrevented: boolean;\r\n      /**\r\n       * Prevent the default action which happens on this event.\r\n       */\r\n      preventDefault(): void;\r\n    }\r\n  : {}) &\r\n  (undefined extends Data\r\n    ? { readonly data?: Readonly<Data> }\r\n    : { readonly data: Readonly<Data> });\r\n\r\nexport type EventListenerCallback<\r\n  EventMap extends EventMapBase,\r\n  EventName extends keyof EventMap,\r\n  EventCanPreventDefault extends\r\n    | boolean\r\n    | undefined = EventMap[EventName]['canPreventDefault'],\r\n> = (\r\n  e: EventArg<\r\n    EventName,\r\n    undefined extends EventCanPreventDefault ? false : EventCanPreventDefault,\r\n    EventMap[EventName]['data']\r\n  >\r\n) => void;\r\n\r\nexport type EventConsumer<EventMap extends EventMapBase> = {\r\n  /**\r\n   * Subscribe to events from the parent navigator.\r\n   *\r\n   * @param type Type of the event (e.g. `focus`, `blur`)\r\n   * @param callback Callback listener which is executed upon receiving the event.\r\n   */\r\n  addListener<EventName extends Keyof<EventMap>>(\r\n    type: EventName,\r\n    callback: EventListenerCallback<EventMap, EventName>\r\n  ): () => void;\r\n  removeListener<EventName extends Keyof<EventMap>>(\r\n    type: EventName,\r\n    callback: EventListenerCallback<EventMap, EventName>\r\n  ): void;\r\n};\r\n\r\nexport type EventEmitter<EventMap extends EventMapBase> = {\r\n  /**\r\n   * Emit an event to child screens.\r\n   *\r\n   * @param options.type Type of the event (e.g. `focus`, `blur`)\r\n   * @param [options.data] Optional information regarding the event.\r\n   * @param [options.target] Key of the target route which should receive the event.\r\n   * If not specified, all routes receive the event.\r\n   */\r\n  emit<EventName extends Keyof<EventMap>>(\r\n    options: {\r\n      type: EventName;\r\n      target?: string;\r\n    } & (EventMap[EventName]['canPreventDefault'] extends true\r\n      ? { canPreventDefault: true }\r\n      : {}) &\r\n      (undefined extends EventMap[EventName]['data']\r\n        ? { data?: EventMap[EventName]['data'] }\r\n        : { data: EventMap[EventName]['data'] })\r\n  ): EventArg<\r\n    EventName,\r\n    EventMap[EventName]['canPreventDefault'],\r\n    EventMap[EventName]['data']\r\n  >;\r\n};\r\n\r\nexport class PrivateValueStore<T extends [any, any, any]> {\r\n  /**\r\n   * UGLY HACK! DO NOT USE THE TYPE!!!\r\n   *\r\n   * TypeScript requires a type to be used to be able to infer it.\r\n   * The type should exist as its own without any operations such as union.\r\n   * So we need to figure out a way to store this type in a property.\r\n   * The problem with a normal property is that it shows up in intelliSense.\r\n   * Adding private keyword works, but the annotation is stripped away in declaration.\r\n   * Turns out if we use an empty string, it doesn't show up in intelliSense.\r\n   */\r\n  protected ''?: T;\r\n}\r\n\r\ntype NavigationHelpersCommon<\r\n  ParamList extends ParamListBase,\r\n  State extends NavigationState = NavigationState,\r\n> = {\r\n  /**\r\n   * Dispatch an action or an update function to the router.\r\n   * The update function will receive the current state,\r\n   *\r\n   * @param action Action object or update function.\r\n   */\r\n  dispatch(\r\n    action: NavigationAction | ((state: Readonly<State>) => NavigationAction)\r\n  ): void;\r\n\r\n  /**\r\n   * Navigate to a screen in the current or parent navigator.\r\n   * If we're already on the screen, update the params instead.\r\n   *\r\n   * @param name Name of the route to navigate to.\r\n   * @param [params] Params object for the route.\r\n   * @param [merge] Whether to merge the params onto the route.\r\n   */\r\n  navigate<RouteName extends keyof ParamList>(\r\n    ...args: {\r\n      [Screen in keyof ParamList]: undefined extends ParamList[Screen]\r\n        ?\r\n            | [screen: Screen]\r\n            | [screen: Screen, params: ParamList[Screen]]\r\n            | [screen: Screen, params: ParamList[Screen], merge: boolean]\r\n        :\r\n            | [screen: Screen, params: ParamList[Screen]]\r\n            | [screen: Screen, params: ParamList[Screen], merge: boolean];\r\n    }[RouteName]\r\n  ): void;\r\n\r\n  /**\r\n   * Navigate to a route in current navigation tree.\r\n   *\r\n   * @param options Object with `name` for the route to navigate to, and a `params` object.\r\n   */\r\n  navigate<RouteName extends keyof ParamList>(\r\n    options: {\r\n      [Screen in keyof ParamList]: {\r\n        name: Screen;\r\n        params: ParamList[Screen];\r\n        path?: string;\r\n        merge?: boolean;\r\n      };\r\n    }[RouteName]\r\n  ): void;\r\n\r\n  /**\r\n   * Navigate to a route in current navigation tree.\r\n   *\r\n   * @deprecated Use `navigate` instead.\r\n   *\r\n   * @param name Name of the route to navigate to.\r\n   * @param [params] Params object for the route.\r\n   */\r\n  navigateDeprecated<RouteName extends keyof ParamList>(\r\n    ...args: ScreenParamsPair<ParamList, RouteName>\r\n  ): void;\r\n\r\n  /**\r\n   * Navigate to a route in current navigation tree.\r\n   *\r\n   * @deprecated Use `navigate` instead.\r\n   *\r\n   * @param options Object with `name` for the route to navigate to, and a `params` object.\r\n   */\r\n  navigateDeprecated<RouteName extends keyof ParamList>(\r\n    options: {\r\n      [Screen in keyof ParamList]: {\r\n        name: Screen;\r\n        params: ParamList[Screen];\r\n        merge?: boolean;\r\n      };\r\n    }[RouteName]\r\n  ): void;\r\n\r\n  /**\r\n   * Preloads the route in current navigation tree.\r\n   *\r\n   * @param name Name of the route to navigate to.\r\n   * @param [params] Params object for the route.\r\n   */\r\n  preload<RouteName extends keyof ParamList>(\r\n    ...args: ScreenParamsPair<ParamList, RouteName>\r\n  ): void;\r\n\r\n  /**\r\n   * Reset the navigation state to the provided state.\r\n   *\r\n   * @param state Navigation state object.\r\n   */\r\n  reset(state: PartialState<State> | State): void;\r\n\r\n  /**\r\n   * Go back to the previous route in history.\r\n   */\r\n  goBack(): void;\r\n\r\n  /**\r\n   * Check if the screen is focused. The method returns `true` if focused, `false` otherwise.\r\n   * Note that this method doesn't re-render screen when the focus changes. So don't use it in `render`.\r\n   * To get notified of focus changes, use `addListener('focus', cb)` and `addListener('blur', cb)`.\r\n   * To conditionally render content based on focus state, use the `useIsFocused` hook.\r\n   */\r\n  isFocused(): boolean;\r\n\r\n  /**\r\n   * Check if dispatching back action will be handled by navigation.\r\n   * Note that this method doesn't re-render screen when the result changes. So don't use it in `render`.\r\n   */\r\n  canGoBack(): boolean;\r\n\r\n  /**\r\n   * Returns the name of the navigator specified in the `name` prop.\r\n   * If no name is specified, returns `undefined`.\r\n   */\r\n  getId(): string | undefined;\r\n\r\n  /**\r\n   * Returns the navigation helpers from a parent navigator based on the ID.\r\n   * If an ID is provided, the navigation helper from the parent navigator with matching ID (including current) will be returned.\r\n   * If no ID is provided, the navigation helper from the immediate parent navigator will be returned.\r\n   *\r\n   * @param id Optional ID of a parent navigator.\r\n   */\r\n  getParent<T = NavigationHelpers<ParamListBase> | undefined>(id?: string): T;\r\n\r\n  /**\r\n   * Returns the navigator's state.\r\n   * Note that this method doesn't re-render screen when the result changes. So don't use it in `render`.\r\n   */\r\n  getState(): State;\r\n  /**\r\n   * Schedules the given state to be used as navigation state when the list of screens defined in the navigator changes\r\n   * instead of automatically calculating the new state, e.g. due to conditional rendering or dynamically defining screens.\r\n   *\r\n   * @param state Navigation state object.\r\n   */\r\n  setStateForNextRouteNamesChange(state: PartialState<State> | State): void;\r\n} & PrivateValueStore<[ParamList, unknown, unknown]>;\r\n\r\nexport type NavigationHelpers<\r\n  ParamList extends ParamListBase,\r\n  EventMap extends EventMapBase = {},\r\n> = NavigationHelpersCommon<ParamList> &\r\n  EventEmitter<EventMap> & {\r\n    /**\r\n     * Update the param object for the route.\r\n     * The new params will be shallow merged with the old one.\r\n     *\r\n     * @param params Params object for the current route.\r\n     */\r\n    setParams<RouteName extends keyof ParamList>(\r\n      params: Partial<ParamList[RouteName]>\r\n    ): void;\r\n  };\r\n\r\nexport type NavigationContainerProps = {\r\n  /**\r\n   * Initial navigation state for the child navigators.\r\n   */\r\n  initialState?: InitialState;\r\n  /**\r\n   * Callback which is called with the latest navigation state when it changes.\r\n   */\r\n  onStateChange?: (state: Readonly<NavigationState> | undefined) => void;\r\n  /**\r\n   * Callback which is called after the navigation tree mounts.\r\n   */\r\n  onReady?: () => void;\r\n  /**\r\n   * Callback which is called when an action is not handled.\r\n   */\r\n  onUnhandledAction?: (action: Readonly<NavigationAction>) => void;\r\n  /**\r\n   * Whether child navigator should handle a navigation action.\r\n   * The child navigator needs to be mounted before it can handle the action.\r\n   * Defaults to `false`.\r\n   *\r\n   * This will be removed in the next major release.\r\n   *\r\n   * @deprecated Use nested navigation API instead\r\n   */\r\n  navigationInChildEnabled?: boolean;\r\n  /**\r\n   * Theme object for the UI elements.\r\n   */\r\n  theme?: ReactNavigation.Theme;\r\n  /**\r\n   * Children elements to render.\r\n   */\r\n  children: React.ReactNode;\r\n};\r\n\r\nexport type NavigationProp<\r\n  ParamList extends {},\r\n  RouteName extends keyof ParamList = Keyof<ParamList>,\r\n  NavigatorID extends string | undefined = undefined,\r\n  State extends NavigationState = NavigationState<ParamList>,\r\n  ScreenOptions extends {} = {},\r\n  EventMap extends EventMapBase = {},\r\n> = Omit<NavigationHelpersCommon<ParamList, State>, 'getParent'> & {\r\n  /**\r\n   * Returns the navigation prop from a parent navigator based on the ID.\r\n   * If an ID is provided, the navigation prop from the parent navigator with matching ID (including current) will be returned.\r\n   * If no ID is provided, the navigation prop from the immediate parent navigator will be returned.\r\n   *\r\n   * @param id Optional ID of a parent navigator.\r\n   */\r\n  getParent<T = NavigationProp<ParamListBase> | undefined>(id?: NavigatorID): T;\r\n\r\n  /**\r\n   * Update the param object for the route.\r\n   * The new params will be shallow merged with the old one.\r\n   *\r\n   * @param params Params object for the current route.\r\n   */\r\n  setParams(\r\n    params: ParamList[RouteName] extends undefined\r\n      ? undefined\r\n      : Partial<ParamList[RouteName]>\r\n  ): void;\r\n\r\n  /**\r\n   * Update the options for the route.\r\n   * The options object will be shallow merged with default options object.\r\n   *\r\n   * @param update Options object or a callback which takes the options from navigator config and returns a new options object.\r\n   */\r\n  setOptions(options: Partial<ScreenOptions>): void;\r\n} & EventConsumer<EventMap & EventMapCore<State>> &\r\n  PrivateValueStore<[ParamList, RouteName, EventMap]>;\r\n\r\nexport type RouteProp<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList = Keyof<ParamList>,\r\n> = Route<Extract<RouteName, string>, ParamList[RouteName]>;\r\n\r\nexport type CompositeNavigationProp<\r\n  A extends NavigationProp<ParamListBase, string, any, any, any>,\r\n  B extends NavigationHelpersCommon<ParamListBase, any>,\r\n> = Omit<A & B, keyof NavigationProp<any>> &\r\n  NavigationProp<\r\n    /**\r\n     * Param list from both navigation objects needs to be combined\r\n     * For example, we should be able to navigate to screens in both A and B\r\n     */\r\n    (A extends NavigationHelpersCommon<infer T> ? T : never) &\r\n      (B extends NavigationHelpersCommon<infer U> ? U : never),\r\n    /**\r\n     * The route name should refer to the route name specified in the first type\r\n     * Ideally it should work for any of them, but it's not possible to infer that way\r\n     */\r\n    A extends NavigationProp<any, infer R> ? R : string,\r\n    /**\r\n     * ID from both navigation objects needs to be combined for `getParent`\r\n     */\r\n    | (A extends NavigationProp<any, any, infer I> ? I : never)\r\n    | (B extends NavigationProp<any, any, infer J> ? J : never),\r\n    /**\r\n     * The type of state should refer to the state specified in the first type\r\n     */\r\n    A extends NavigationProp<any, any, any, infer S> ? S : NavigationState,\r\n    /**\r\n     * Screen options should refer to the options specified in the first type\r\n     */\r\n    A extends NavigationProp<any, any, any, any, infer O> ? O : {},\r\n    /**\r\n     * Event consumer config should refer to the config specified in the first type\r\n     * This allows typechecking `addListener`/`removeListener`\r\n     */\r\n    A extends NavigationProp<any, any, any, any, any, infer E> ? E : {}\r\n  >;\r\n\r\nexport type CompositeScreenProps<\r\n  A extends {\r\n    navigation: NavigationProp<\r\n      ParamListBase,\r\n      string,\r\n      string | undefined,\r\n      any,\r\n      any,\r\n      any\r\n    >;\r\n    route: RouteProp<ParamListBase>;\r\n  },\r\n  B extends {\r\n    navigation: NavigationHelpersCommon<any, any>;\r\n  },\r\n> = {\r\n  navigation: CompositeNavigationProp<A['navigation'], B['navigation']>;\r\n  route: A['route'];\r\n};\r\n\r\nexport type Descriptor<\r\n  ScreenOptions extends {},\r\n  Navigation extends NavigationProp<any, any, any, any, any, any>,\r\n  Route extends RouteProp<any, any>,\r\n> = {\r\n  /**\r\n   * Render the component associated with this route.\r\n   */\r\n  render(): JSX.Element;\r\n\r\n  /**\r\n   * Options for the route.\r\n   */\r\n  options: ScreenOptions;\r\n\r\n  /**\r\n   * Route object for the screen\r\n   */\r\n  route: Route;\r\n\r\n  /**\r\n   * Navigation object for the screen\r\n   */\r\n  navigation: Navigation;\r\n};\r\n\r\nexport type ScreenListeners<\r\n  State extends NavigationState,\r\n  EventMap extends EventMapBase,\r\n> = Partial<{\r\n  [EventName in keyof (EventMap & EventMapCore<State>)]: EventListenerCallback<\r\n    EventMap & EventMapCore<State>,\r\n    EventName\r\n  >;\r\n}>;\r\n\r\ntype ScreenComponentType<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList,\r\n> =\r\n  | React.ComponentType<{\r\n      route: RouteProp<ParamList, RouteName>;\r\n      navigation: any;\r\n    }>\r\n  | React.ComponentType<{}>;\r\n\r\nexport type RouteConfigComponent<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList,\r\n> =\r\n  | {\r\n      /**\r\n       * React component to render for this screen.\r\n       */\r\n      component: ScreenComponentType<ParamList, RouteName>;\r\n      getComponent?: never;\r\n      children?: never;\r\n    }\r\n  | {\r\n      /**\r\n       * Lazily get a React component to render for this screen.\r\n       */\r\n      getComponent: () => ScreenComponentType<ParamList, RouteName>;\r\n      component?: never;\r\n      children?: never;\r\n    }\r\n  | {\r\n      /**\r\n       * Render callback to render content of this screen.\r\n       */\r\n      children: (props: {\r\n        route: RouteProp<ParamList, RouteName>;\r\n        navigation: any;\r\n      }) => React.ReactNode;\r\n      component?: never;\r\n      getComponent?: never;\r\n    };\r\n\r\nexport type RouteConfigProps<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase,\r\n  Navigation,\r\n> = {\r\n  /**\r\n   * Optional key for this screen. This doesn't need to be unique.\r\n   * If the key changes, existing screens with this name will be removed or reset.\r\n   * Useful when we have some common screens and have conditional rendering.\r\n   */\r\n  navigationKey?: string;\r\n\r\n  /**\r\n   * Route name of this screen.\r\n   */\r\n  name: RouteName;\r\n\r\n  /**\r\n   * Navigator options for this screen.\r\n   */\r\n  options?:\r\n    | ScreenOptions\r\n    | ((props: {\r\n        route: RouteProp<ParamList, RouteName>;\r\n        navigation: Navigation;\r\n        theme: ReactNavigation.Theme;\r\n      }) => ScreenOptions);\r\n\r\n  /**\r\n   * Event listeners for this screen.\r\n   */\r\n  listeners?:\r\n    | ScreenListeners<State, EventMap>\r\n    | ((props: {\r\n        route: RouteProp<ParamList, RouteName>;\r\n        navigation: Navigation;\r\n      }) => ScreenListeners<State, EventMap>);\r\n\r\n  /**\r\n   * Layout for this screen.\r\n   * Useful for wrapping the screen with custom containers.\r\n   * e.g. for styling, error boundaries, suspense, etc.\r\n   */\r\n  layout?: (props: {\r\n    route: RouteProp<ParamList, RouteName>;\r\n    navigation: Navigation;\r\n    theme: ReactNavigation.Theme;\r\n    children: React.ReactElement;\r\n  }) => React.ReactElement;\r\n\r\n  /**\r\n   * Function to return an unique ID for this screen.\r\n   * Receives an object with the route params.\r\n   * For a given screen name, there will always be only one screen corresponding to an ID.\r\n   * If `undefined` is returned, it acts same as no `getId` being specified.\r\n   */\r\n  getId?: ({\r\n    params,\r\n  }: {\r\n    params: Readonly<ParamList[RouteName]>;\r\n  }) => string | undefined;\r\n\r\n  /**\r\n   * Initial params object for the route.\r\n   */\r\n  initialParams?: Partial<ParamList[RouteName]>;\r\n};\r\n\r\nexport type RouteConfig<\r\n  ParamList extends ParamListBase,\r\n  RouteName extends keyof ParamList,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase,\r\n  Navigation,\r\n> = RouteConfigProps<\r\n  ParamList,\r\n  RouteName,\r\n  State,\r\n  ScreenOptions,\r\n  EventMap,\r\n  Navigation\r\n> &\r\n  RouteConfigComponent<ParamList, RouteName>;\r\n\r\nexport type RouteGroupConfig<\r\n  ParamList extends ParamListBase,\r\n  ScreenOptions extends {},\r\n  Navigation,\r\n> = {\r\n  /**\r\n   * Optional key for the screens in this group.\r\n   * If the key changes, all existing screens in this group will be removed or reset.\r\n   */\r\n  navigationKey?: string;\r\n\r\n  /**\r\n   * Navigator options for this screen.\r\n   */\r\n  screenOptions?:\r\n    | ScreenOptions\r\n    | ((props: {\r\n        route: RouteProp<ParamList, keyof ParamList>;\r\n        navigation: Navigation;\r\n        theme: ReactNavigation.Theme;\r\n      }) => ScreenOptions);\r\n\r\n  /**\r\n   * Layout for the screens inside the group.\r\n   * This will override the `screenLayout` of parent group or navigator.\r\n   */\r\n  screenLayout?:\r\n    | ((props: {\r\n        route: RouteProp<ParamList, keyof ParamList>;\r\n        navigation: Navigation;\r\n        theme: ReactNavigation.Theme;\r\n        children: React.ReactElement;\r\n      }) => React.ReactElement)\r\n    | {\r\n        // FIXME: TypeScript doesn't seem to infer `navigation` correctly without this\r\n      };\r\n\r\n  /**\r\n   * Children React Elements to extract the route configuration from.\r\n   * Only `Screen`, `Group` and `React.Fragment` are supported as children.\r\n   */\r\n  children: React.ReactNode;\r\n};\r\n\r\nexport type NavigationContainerEventMap = {\r\n  /**\r\n   * Event which fires when the navigation state changes.\r\n   */\r\n  state: {\r\n    data: {\r\n      /**\r\n       * The updated state object after the state change.\r\n       */\r\n      state: NavigationState | PartialState<NavigationState> | undefined;\r\n    };\r\n  };\r\n  /**\r\n   * Event which fires when current options changes.\r\n   */\r\n  options: { data: { options: object } };\r\n  /**\r\n   * Event which fires when an action is dispatched.\r\n   * Only intended for debugging purposes, don't use it for app logic.\r\n   * This event will be emitted before state changes have been applied.\r\n   */\r\n  __unsafe_action__: {\r\n    data: {\r\n      /**\r\n       * The action object which was dispatched.\r\n       */\r\n      action: NavigationAction;\r\n      /**\r\n       * Whether the action was a no-op, i.e. resulted any state changes.\r\n       */\r\n      noop: boolean;\r\n      /**\r\n       * Stack trace of the action, this will only be available during development.\r\n       */\r\n      stack: string | undefined;\r\n    };\r\n  };\r\n};\r\n\r\ntype NotUndefined<T> = T extends undefined ? never : T;\r\n\r\nexport type ParamListRoute<ParamList extends ParamListBase> = {\r\n  [RouteName in keyof ParamList]: NavigatorScreenParams<{}> extends ParamList[RouteName]\r\n    ? NotUndefined<ParamList[RouteName]> extends NavigatorScreenParams<infer T>\r\n      ? ParamListRoute<T>\r\n      : Route<Extract<RouteName, string>, ParamList[RouteName]>\r\n    : Route<Extract<RouteName, string>, ParamList[RouteName]>;\r\n}[keyof ParamList];\r\n\r\ntype MaybeParamListRoute<ParamList extends {}> = ParamList extends ParamListBase\r\n  ? ParamListRoute<ParamList>\r\n  : Route<string>;\r\n\r\nexport type NavigationContainerRef<ParamList extends {}> =\r\n  NavigationHelpers<ParamList> &\r\n    EventConsumer<NavigationContainerEventMap> & {\r\n      /**\r\n       * Reset the navigation state of the root navigator to the provided state.\r\n       *\r\n       * @param state Navigation state object.\r\n       */\r\n      resetRoot(state?: PartialState<NavigationState> | NavigationState): void;\r\n      /**\r\n       * Get the rehydrated navigation state of the navigation tree.\r\n       */\r\n      getRootState(): NavigationState;\r\n      /**\r\n       * Get the currently focused navigation route.\r\n       */\r\n      getCurrentRoute(): MaybeParamListRoute<ParamList> | undefined;\r\n      /**\r\n       * Get the currently focused route's options.\r\n       */\r\n      getCurrentOptions(): object | undefined;\r\n      /**\r\n       * Whether the navigation container is ready to handle actions.\r\n       */\r\n      isReady(): boolean;\r\n      /**\r\n       * Stub function for setOptions on navigation object for use with useNavigation.\r\n       */\r\n      setOptions(): never;\r\n      /**\r\n       * Stub function for getParent on navigation object for use with useNavigation.\r\n       */\r\n      getParent(): undefined;\r\n    };\r\n\r\nexport type NavigationContainerRefWithCurrent<ParamList extends {}> =\r\n  NavigationContainerRef<ParamList> & {\r\n    current: NavigationContainerRef<ParamList> | null;\r\n  };\r\n\r\nexport type NavigationListBase<ParamList extends ParamListBase> = {\r\n  [RouteName in keyof ParamList]: unknown;\r\n};\r\n\r\nexport type TypeBag<\r\n  ParamList extends ParamListBase,\r\n  NavigatorID extends string | undefined,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase,\r\n  NavigationList extends NavigationListBase<ParamList>,\r\n  Navigator extends React.ComponentType<any>,\r\n> = {\r\n  ParamList: ParamList;\r\n  NavigatorID: NavigatorID;\r\n  State: State;\r\n  ScreenOptions: ScreenOptions;\r\n  EventMap: EventMap;\r\n  NavigationList: NavigationList;\r\n  Navigator: Navigator;\r\n};\r\n\r\nexport type NavigatorTypeBagBase = {\r\n  ParamList: {};\r\n  NavigatorID: string | undefined;\r\n  State: NavigationState;\r\n  ScreenOptions: {};\r\n  EventMap: {};\r\n  NavigationList: NavigationListBase<ParamListBase>;\r\n  Navigator: React.ComponentType<any>;\r\n};\r\n\r\nexport type NavigatorTypeBag<\r\n  ParamList extends ParamListBase,\r\n  NavigatorID extends string | undefined,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase,\r\n  NavigationList extends NavigationListBase<ParamList>,\r\n  Navigator extends React.ComponentType<any>,\r\n> = {\r\n  ParamList: ParamList;\r\n  NavigatorID: NavigatorID;\r\n  State: State;\r\n  ScreenOptions: ScreenOptions;\r\n  EventMap: EventMap;\r\n  NavigationList: NavigationList;\r\n  Navigator: Navigator;\r\n};\r\n\r\nexport type TypedNavigator<\r\n  Bag extends NavigatorTypeBagBase,\r\n  Config = unknown,\r\n> = TypedNavigatorInternal<\r\n  Bag['ParamList'],\r\n  Bag['NavigatorID'],\r\n  Bag['State'],\r\n  Bag['ScreenOptions'],\r\n  Bag['EventMap'],\r\n  Bag['NavigationList'],\r\n  Bag['Navigator']\r\n> &\r\n  (undefined extends Config ? {} : { config: Config });\r\n\r\ntype TypedNavigatorInternal<\r\n  ParamList extends ParamListBase,\r\n  NavigatorID extends string | undefined,\r\n  State extends NavigationState,\r\n  ScreenOptions extends {},\r\n  EventMap extends EventMapBase,\r\n  NavigationList extends NavigationListBase<ParamList>,\r\n  Navigator extends React.ComponentType<any>,\r\n> = {\r\n  /**\r\n   * Navigator component which manages the child screens.\r\n   */\r\n  Navigator: React.ComponentType<\r\n    Omit<\r\n      React.ComponentProps<Navigator>,\r\n      keyof DefaultNavigatorOptions<any, any, any, any, any, any>\r\n    > &\r\n      DefaultNavigatorOptions<\r\n        ParamList,\r\n        NavigatorID,\r\n        State,\r\n        ScreenOptions,\r\n        EventMap,\r\n        NavigationList[keyof ParamList]\r\n      >\r\n  >;\r\n  /**\r\n   * Component used for grouping multiple route configuration.\r\n   */\r\n  Group: React.ComponentType<\r\n    RouteGroupConfig<ParamList, ScreenOptions, NavigationList[keyof ParamList]>\r\n  >;\r\n  /**\r\n   * Component used for specifying route configuration.\r\n   */\r\n  Screen: <RouteName extends keyof ParamList>(\r\n    _: RouteConfig<\r\n      ParamList,\r\n      RouteName,\r\n      State,\r\n      ScreenOptions,\r\n      EventMap,\r\n      NavigationList[RouteName]\r\n    >\r\n  ) => null;\r\n};\r\n\r\nexport type NavigatorScreenParams<ParamList extends {}> =\r\n  | {\r\n      screen?: never;\r\n      params?: never;\r\n      initial?: never;\r\n      path?: string;\r\n      state: PartialState<NavigationState> | NavigationState | undefined;\r\n    }\r\n  | {\r\n      [RouteName in keyof ParamList]: undefined extends ParamList[RouteName]\r\n        ? {\r\n            screen: RouteName;\r\n            params?: ParamList[RouteName];\r\n            initial?: boolean;\r\n            path?: string;\r\n            state?: never;\r\n          }\r\n        : {\r\n            screen: RouteName;\r\n            params: ParamList[RouteName];\r\n            initial?: boolean;\r\n            path?: string;\r\n            state?: never;\r\n          };\r\n    }[keyof ParamList];\r\n\r\ntype PathConfigAlias = {\r\n  /**\r\n   * Path string to match against.\r\n   * e.g. `/users/:id` will match `/users/1` and extract `id` param as `1`.\r\n   */\r\n  path: string;\r\n  /**\r\n   * Whether the path should be consider parent paths or use the exact path.\r\n   * By default, paths are relating to the path config on the parent screen.\r\n   * If `exact` is set to `true`, the parent path configuration is not used.\r\n   */\r\n  exact?: boolean;\r\n  /**\r\n   * An object mapping the param name to a function which parses the param value.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * parse: {\r\n   *   id: Number,\r\n   *   date: (value) => new Date(value)\r\n   * }\r\n   * ```\r\n   */\r\n  parse?: Record<string, (value: string) => any>;\r\n};\r\n\r\nexport type PathConfig<ParamList extends {}> = Partial<PathConfigAlias> & {\r\n  /**\r\n   * An object mapping the param name to a function which converts the param value to a string.\r\n   * By default, all params are converted to strings using `String(value)`.\r\n   *\r\n   * @example\r\n   * ```js\r\n   * stringify: {\r\n   *   date: (value) => value.toISOString()\r\n   * }\r\n   * ```\r\n   */\r\n  stringify?: Record<string, (value: any) => string>;\r\n  /**\r\n   * Additional path alias that will be matched to the same screen.\r\n   */\r\n  alias?: (string | PathConfigAlias)[];\r\n  /**\r\n   * Path configuration for child screens.\r\n   */\r\n  screens?: PathConfigMap<ParamList>;\r\n  /**\r\n   * Name of the initial route to use for the navigator when the path matches.\r\n   */\r\n  initialRouteName?: keyof ParamList;\r\n};\r\n\r\nexport type PathConfigMap<ParamList extends {}> = {\r\n  [RouteName in keyof ParamList]?: NonNullable<\r\n    ParamList[RouteName]\r\n  > extends NavigatorScreenParams<infer T extends {}>\r\n    ? string | PathConfig<T>\r\n    : string | Omit<PathConfig<{}>, 'screens' | 'initialRouteName'>;\r\n};\r\n"],"mappings":";;;;;;AA6NO,MAAMA,iBAAiB,CAA4B;AAYzDC,OAAA,CAAAD,iBAAA,GAAAA,iBAAA","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}